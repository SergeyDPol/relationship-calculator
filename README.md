# Калькулятор отношений на Lua

## Что такое Lua?
Lua - это интерпретируемый язак программирования, основной целью которого является высокая экспрессоивность при сохранении простоты синтаксиса. Lua зародился в 1993 году в Католическом университете Рио-де-Жанейро в Бразилии. С самого начала Lua задумывался как язык-связка, способный на высоком уровне вызывать конструкции написанные на других, более высокопроизводительных языках, в частности C.

Lua имеет очень легковесный интерптератор (интерпретатор языка вместе со стандартной библиотекой занимает около 220KiB), и хорошо интегрируется с C, что позволяет встраивать интерпретатор Lua в приложения для содания плагинов или добавления программатического контроля. Наиболее известными приложениями, использующими Lua таким образом являются Neovim, Adobe Lightroom, Roblox, Nmap, mpv и World of Warcraft.

## Калькулятор отношений
### DSL для задания отношений
В качестве DSL для регистрации отношений мы решили использовать сам Lua. Для регистрации отношения пользователю необходимо вызвать функцию `register_relations`, которая принимает на вход название отношения и таблицу, содержащую последовательность отношений которые необходимо пройти в обратном порядке чтобы достичь этот тип родственника. Пример: `register_relations("grandmother", {"female", "parent", "parent"})`. Итоговая последовательность отношений таким образом напоминает естественные предложения на английском языке, если поместить предлог "of" перед каждым отношением, не являющимся фильтром по полу. A grandmother is a female parent of the parent. Программой предопределены отношения parent, child, spouse, а также фильтры male и female. Также самым последним отношением по умолчанию является фильтрация элемента, для которого вызывается цепочка отношений. Таким образом, ни один человек не является сам себе братом или каким-либо другим родственником.

Поскольку пользователь имеет доступ ко всем конструкциям языка (за исключением доступа к библиотекам), он может задавать отношения программатически:
```lua
local relation = {"parent", "parent"}
local relation_name = "grandparent"
local order_prefix = "great"

for i=1,11 do
	register_relations(relation_name, relation)
	relation[#relation+1] = "parent"
	relation_name = order_prefix .. relation_name
end
```
Данный пример задёт прародителей до 10го колена.
### Поиск отношений для заданного человека
Поиск людей, имеющих то или иное отношение к рассматриваемому человеку реализован при помощи DFS, написанного при помощи замыканий. Для понимания решения, сначала необходимо объяснить, что такое итераторы в Lua. Итератор - это функция, которая на каждом вызове возвращает следующее значение из некоторого списка. Сами итераторы создаются при помощи фабрик итераторов. Пример:
```lua
function values (table)
	local i = 0
	return function () i = i + 1; return t[i] end
end
```
Данная функция создаёт итератор по числовым ключам для заданной таблицы.

Наше решение построено поверх таких итераторов: для каждого человека предопределены фабрики итераторов по детям, родителям и супругу/супруге. Также у каждого человека есть фильтр по полу, который также реализован при помощи итераторов. Таким образом, поскольку отношения задаются композицией, у нас получается цепочка из итераторов. Для поиска людей, имеющих отношение к рассматриваемому человеку, мы итерируемся по людям, состоящим в последнем указанном в списке отношении к рассматриваемому человеку. Для каждого из них мы ищем людей, состоящих в отношении, которое идёт вторым с конца, и т.д.
### Чтение данных о людях
Чтение данных о людях основано на примере тестового файла `input.txt`, где для чтения реализовано 3 парсера в виде 3-ех глобальных функций:
1. ParseName - для получения имени людей, чтобы их инициализировать
2. ParseSpouse - для получения связей мужа/жены
3. ParseChild - для парсинга связей детей

Для того, чтобы сформировались все необходимые нам связи, мы их описываем в файле `register.lua` (в директории examples)

```lua
-- Супруги
register_relations("husband", {"male", "spouse"});
register_relations("wife", {"female", "spouse"});

truncated...
```

На основе описанных связей в `register.lua`, мы начинаем вычитывать все описанные связи в `input.txt`, запуская все 3 парсера для обработки строк. Если одному из парсеров удалось обработать строку, то в зависимости от парсера применяется следующая логика:

1. Для `ParseName` мы инициализируем человека:

```lua
local gender_for_person = "male"
if (gender == "Ж") then
	gender_for_person = "female"
end
local new_person = person:new({
	name = name,
	gender = gender_for_person
})
person_by_name[new_person.properties.name] = new_person
```

Всех людей складываем в 'таблицу' (aka словарь), где ключ - это имя человека, а значение - сам объект `person`

2. Для `ParseSpouse` мы устанавливаем для людей связи мужа/жены

```lua
local husband_person = person_by_name[husband]
local wife_person = person_by_name[wife]

husband_person.properties.spouse = wife_person
wife_person.properties.spouse = husband_person
```

3. Для `ParseChild` мы устанавливаем родственные связи родитель -> ребенок:

```lua
local child_person = person_by_name[child]
local parent_person = person_by_name[parent]

if (child_person.properties.parent == nil) then
	child_person.properties.parent = {}
end

if (parent_person.properties.child == nil) then
	parent_person.properties.child = {}
end

child_person.properties.parent[#child_person.properties.parent + 1] = parent_person
parent_person.properties.child[#parent_person.properties.child + 1] = child_person
```

На основе чего после всей обработки получаем полный список людей с установленными необходимыми связями в табличке `person_by_name`

### Интерактивный промпт

Интерактивный промпт реализован через цикл с ожиданием пользовательского ввода команд. Основная команда:

```bash
get {name} {relation}
```

Команда get позволяет получить связь человека по имени и виду его родственной связи, например:

```bash
Команда (или 'exit' для выхода): get Ксения father
Разумник
```

В случае, если связей много (например, несколько сыновей/дочерей), то вывод будет идти в несколько строк подряд:

```bash
Команда (или 'exit' для выхода): get Анатолий son
Аркадий
Пётр
Феликс
```

Реализации функций `get` и `help`, которые можно вызвать из терминала, реализованы в `utils/commands.lua` и в случае добавления новых команд/функций достаточно добавить наименование команды по ключу и реализовать логику данной функции, например:

```lua
Actions = {
	["get"] = function()
	end,
	["foo"] = function()
	end,
	["do_something"] = function()
	end
}
```

